"""Tests for mm_ready.schema_parser â€” SQL dump parsing into ParsedSchema."""

from __future__ import annotations

import textwrap

import pytest

from mm_ready.schema_parser import (
    ColumnDef,
    ConstraintDef,
    EnumTypeDef,
    ExtensionDef,
    IndexDef,
    ParsedSchema,
    RuleDef,
    SequenceDef,
    TableDef,
    parse_dump,
)


# ---------------------------------------------------------------------------
# Helper: write SQL text to a temp file and parse it
# ---------------------------------------------------------------------------

def _parse(tmp_path, sql: str) -> ParsedSchema:
    f = tmp_path / "dump.sql"
    f.write_text(textwrap.dedent(sql), encoding="utf-8")
    return parse_dump(str(f))


# ---------------------------------------------------------------------------
# PG version extraction
# ---------------------------------------------------------------------------

class TestPgVersion:
    def test_extracts_version(self, tmp_path):
        schema = _parse(tmp_path, """\
            -- Dumped from database version 14.8
            -- Dumped by pg_dump version 14.8
        """)
        assert schema.pg_version == "14.8"

    def test_no_version_header(self, tmp_path):
        schema = _parse(tmp_path, "SELECT 1;")
        assert schema.pg_version == ""


# ---------------------------------------------------------------------------
# CREATE TABLE parsing
# ---------------------------------------------------------------------------

class TestCreateTable:
    def test_basic_table(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.users (
                id integer NOT NULL,
                name character varying(100),
                active boolean DEFAULT true NOT NULL
            );
        """)
        assert len(schema.tables) == 1
        tbl = schema.tables[0]
        assert tbl.schema_name == "public"
        assert tbl.table_name == "users"
        assert len(tbl.columns) == 3
        assert tbl.columns[0].name == "id"
        assert tbl.columns[0].not_null is True
        assert tbl.columns[1].name == "name"
        assert tbl.columns[1].not_null is False
        assert tbl.columns[2].default_expr is not None

    def test_unlogged_table(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE UNLOGGED TABLE public.cache (
                key text NOT NULL,
                val text
            );
        """)
        assert schema.tables[0].unlogged is True

    def test_inherits(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.child (
                extra integer
            ) INHERITS (public.parent);
        """)
        assert len(schema.tables[0].inherits) == 1
        assert "public.parent" in schema.tables[0].inherits

    def test_partition_by(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.events (
                id bigint NOT NULL,
                created_at timestamp NOT NULL
            ) PARTITION BY RANGE (created_at);
        """)
        assert schema.tables[0].partition_by is not None
        assert "RANGE" in schema.tables[0].partition_by.upper()

    def test_excludes_pg_catalog(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE pg_catalog.pg_test (
                id integer
            );
        """)
        assert len(schema.tables) == 0

    def test_identity_column_inline(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.items (
                id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
                name text
            );
        """)
        col = schema.tables[0].columns[0]
        assert col.identity is not None
        assert "BY DEFAULT" in col.identity

    def test_generated_column(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.products (
                price numeric NOT NULL,
                tax numeric NOT NULL,
                total numeric GENERATED ALWAYS AS (price + tax) STORED
            );
        """)
        col = schema.tables[0].columns[2]
        assert col.generated_expr is not None
        assert "price" in col.generated_expr


# ---------------------------------------------------------------------------
# Constraints
# ---------------------------------------------------------------------------

class TestConstraints:
    def test_primary_key(self, tmp_path):
        schema = _parse(tmp_path, """\
            ALTER TABLE ONLY public.users
                ADD CONSTRAINT users_pkey PRIMARY KEY (id);
        """)
        assert len(schema.constraints) == 1
        con = schema.constraints[0]
        assert con.constraint_type == "PRIMARY KEY"
        assert con.columns == ["id"]
        assert con.table_name == "users"

    def test_unique_constraint(self, tmp_path):
        schema = _parse(tmp_path, """\
            ALTER TABLE ONLY public.users
                ADD CONSTRAINT users_email_key UNIQUE (email);
        """)
        con = schema.constraints[0]
        assert con.constraint_type == "UNIQUE"
        assert con.columns == ["email"]

    def test_foreign_key(self, tmp_path):
        schema = _parse(tmp_path, """\
            ALTER TABLE ONLY public.orders
                ADD CONSTRAINT orders_user_fk FOREIGN KEY (user_id)
                REFERENCES public.users(id) ON DELETE CASCADE;
        """)
        con = schema.constraints[0]
        assert con.constraint_type == "FOREIGN KEY"
        assert con.columns == ["user_id"]
        assert con.ref_table == "users"
        assert con.on_delete == "CASCADE"

    def test_foreign_key_on_update(self, tmp_path):
        schema = _parse(tmp_path, """\
            ALTER TABLE ONLY public.orders
                ADD CONSTRAINT orders_user_fk FOREIGN KEY (user_id)
                REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE SET NULL;
        """)
        con = schema.constraints[0]
        assert con.on_update == "CASCADE"
        assert con.on_delete == "SET NULL"

    def test_deferrable_constraint(self, tmp_path):
        schema = _parse(tmp_path, """\
            ALTER TABLE ONLY public.items
                ADD CONSTRAINT items_code_key UNIQUE (code) DEFERRABLE INITIALLY DEFERRED;
        """)
        con = schema.constraints[0]
        assert con.deferrable is True
        assert con.initially_deferred is True

    def test_exclude_constraint(self, tmp_path):
        schema = _parse(tmp_path, """\
            ALTER TABLE ONLY public.bookings
                ADD CONSTRAINT no_overlap EXCLUDE USING gist (room WITH =, period WITH &&);
        """)
        con = schema.constraints[0]
        assert con.constraint_type == "EXCLUDE"

    def test_inline_primary_key(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.things (
                id integer NOT NULL,
                name text,
                PRIMARY KEY (id)
            );
        """)
        pks = [c for c in schema.constraints if c.constraint_type == "PRIMARY KEY"]
        assert len(pks) == 1
        assert pks[0].columns == ["id"]


# ---------------------------------------------------------------------------
# Indexes
# ---------------------------------------------------------------------------

class TestIndexes:
    def test_basic_index(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE INDEX idx_users_name ON public.users USING btree (name);
        """)
        assert len(schema.indexes) == 1
        idx = schema.indexes[0]
        assert idx.name == "idx_users_name"
        assert idx.table_name == "users"
        assert idx.is_unique is False
        assert idx.index_method == "btree"

    def test_unique_index(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE UNIQUE INDEX idx_users_email ON public.users USING btree (email);
        """)
        assert schema.indexes[0].is_unique is True

    def test_index_columns(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE INDEX idx_orders_multi ON public.orders USING btree (user_id, created_at);
        """)
        assert schema.indexes[0].columns == ["user_id", "created_at"]


# ---------------------------------------------------------------------------
# Sequences
# ---------------------------------------------------------------------------

class TestSequences:
    def test_basic_sequence(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE SEQUENCE public.users_id_seq
                AS integer
                START WITH 1
                INCREMENT BY 1
                NO MINVALUE
                NO MAXVALUE
                CACHE 1;
        """)
        assert len(schema.sequences) == 1
        seq = schema.sequences[0]
        assert seq.sequence_name == "users_id_seq"
        assert seq.data_type == "integer"
        assert seq.start_value == 1
        assert seq.increment == 1

    def test_sequence_owned_by(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE SEQUENCE public.users_id_seq AS integer START WITH 1 INCREMENT BY 1;
            ALTER SEQUENCE public.users_id_seq OWNED BY public.users.id;
        """)
        seq = schema.sequences[0]
        assert seq.owned_by_table == "public.users"
        assert seq.owned_by_column == "id"


# ---------------------------------------------------------------------------
# ALTER TABLE SET DEFAULT (nextval binding)
# ---------------------------------------------------------------------------

class TestAlterSetDefault:
    def test_nextval_default(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.users (
                id integer NOT NULL,
                name text
            );
            ALTER TABLE ONLY public.users ALTER COLUMN id SET DEFAULT nextval('public.users_id_seq'::regclass);
        """)
        col = schema.tables[0].columns[0]
        assert col.default_expr is not None
        assert "nextval" in col.default_expr


# ---------------------------------------------------------------------------
# ALTER TABLE ADD GENERATED AS IDENTITY
# ---------------------------------------------------------------------------

class TestAlterAddIdentity:
    def test_identity_always(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.items (
                id integer NOT NULL,
                name text
            );
            ALTER TABLE ONLY public.items ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY;
        """)
        col = schema.tables[0].columns[0]
        assert col.identity == "ALWAYS"

    def test_identity_by_default(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TABLE public.items (
                id integer NOT NULL,
                name text
            );
            ALTER TABLE ONLY public.items ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;
        """)
        col = schema.tables[0].columns[0]
        assert col.identity == "BY DEFAULT"


# ---------------------------------------------------------------------------
# Extensions
# ---------------------------------------------------------------------------

class TestExtensions:
    def test_create_extension(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;
        """)
        assert len(schema.extensions) == 1
        assert schema.extensions[0].name == "pg_trgm"
        assert schema.extensions[0].schema_name == "public"

    def test_extension_no_schema(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE EXTENSION plpgsql;
        """)
        assert schema.extensions[0].name == "plpgsql"


# ---------------------------------------------------------------------------
# ENUM types
# ---------------------------------------------------------------------------

class TestEnumTypes:
    def test_enum_type(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE TYPE public.status AS ENUM (
                'active',
                'inactive',
                'pending'
            );
        """)
        assert len(schema.enum_types) == 1
        e = schema.enum_types[0]
        assert e.type_name == "status"
        assert e.labels == ["active", "inactive", "pending"]


# ---------------------------------------------------------------------------
# Rules
# ---------------------------------------------------------------------------

class TestRules:
    def test_instead_rule(self, tmp_path):
        schema = _parse(tmp_path, """\
            CREATE RULE no_delete AS ON DELETE TO public.important DO INSTEAD NOTHING;
        """)
        assert len(schema.rules) == 1
        r = schema.rules[0]
        assert r.rule_name == "no_delete"
        assert r.event == "DELETE"
        assert r.is_instead is True
        assert r.table_name == "important"


# ---------------------------------------------------------------------------
# Search path tracking
# ---------------------------------------------------------------------------

class TestSearchPath:
    def test_search_path_sets_default_schema(self, tmp_path):
        schema = _parse(tmp_path, """\
            SELECT pg_catalog.set_config('search_path', 'myschema', false);
            CREATE TABLE mytable (
                id integer NOT NULL
            );
        """)
        assert schema.tables[0].schema_name == "myschema"


# ---------------------------------------------------------------------------
# ParsedSchema helper methods
# ---------------------------------------------------------------------------

class TestParsedSchemaHelpers:
    def test_get_table(self):
        schema = ParsedSchema()
        t = TableDef(schema_name="public", table_name="users")
        schema.tables.append(t)
        assert schema.get_table("public", "users") is t
        assert schema.get_table("public", "nope") is None

    def test_get_constraints_for_table(self):
        schema = ParsedSchema()
        pk = ConstraintDef(
            name="pk", constraint_type="PRIMARY KEY",
            table_schema="public", table_name="users", columns=["id"],
        )
        fk = ConstraintDef(
            name="fk", constraint_type="FOREIGN KEY",
            table_schema="public", table_name="users", columns=["org_id"],
        )
        other = ConstraintDef(
            name="other_pk", constraint_type="PRIMARY KEY",
            table_schema="public", table_name="orders", columns=["id"],
        )
        schema.constraints.extend([pk, fk, other])
        assert len(schema.get_constraints_for_table("public", "users")) == 2
        assert len(schema.get_constraints_for_table("public", "users", "PRIMARY KEY")) == 1
        assert len(schema.get_constraints_for_table("public", "orders")) == 1

    def test_get_indexes_for_table(self):
        schema = ParsedSchema()
        idx = IndexDef(name="idx1", table_schema="public", table_name="users")
        schema.indexes.append(idx)
        assert len(schema.get_indexes_for_table("public", "users")) == 1
        assert len(schema.get_indexes_for_table("public", "other")) == 0
